https://www.oreilly.com/live-events/agentic-ai-security-bootcamp/0642572236106/

#Here’s the ready-to-run GitHub repo layout for the MAS Sleeper-Agent Threat-Modelling Lab (Week 4 of the Agentic AI Security Bootcamp).
Copy this structure into a new repo, open it in VS Code, and you’ll be able to run and debug everything immediately.

#Before you run this code, make sure that you use local containerised sandbox using Docker + kind (Kubernetes in Docker) + Python virtualenv

#Secure setup (commands)

# install docker (Ubuntu example)
sudo apt update && sudo apt install -y ca-certificates curl gnupg lsb-release
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] \
  https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt update && sudo apt install -y docker-ce docker-ce-cli containerd.io

# install kind (Kubernetes in Docker)
curl -Lo ./kind https://kind.sigs.k8s.io/dl/latest/kind-linux-amd64 && chmod +x ./kind && sudo mv ./kind /usr/local/bin/

# create a cluster with limited resources (adjust as needed)
cat <<EOF > kind-config.yaml
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  extraPortMappings:
  - containerPort: 30000
    hostPort: 30000
    protocol: TCP
EOF

kind create cluster --config kind-config.yaml --name mas-lab

# create Python venv and install deps
python3 -m venv .venv && . .venv/bin/activate
pip install -r requirements.txt   # use repo's requirements.txt

Network security: block egress if you want a fully air-gapped lab:

# example: use host firewall to block outbound except package manager / registry
sudo iptables -A OUTPUT -m owner --uid-owner 1000 -j DROP   # replace with refined rules

----
#Logging schema (use JSON per event)
#Each message / observation in the log should include these fields so you can map A2A, MCP, AGNTCY:

 1. {
 2.   "timestamp": "2025-10-27T12:34:56.789Z",
 3.   "session_id": "sess-abc-001",
 4.   "step": 123,
 5.   "sender": "agent_07",
 6.   "recipient": "agent_12",          // or "broadcast"
 7.   "channel": "A2A"| "MCP" | "TOOL", // A2A = Agent-to-Agent, MCP = Model Context Protocol, TOOL = external tool call
 8.   "mcp_context_id": "ctx-445",      // only for MCP messages
 9.   "message_type": "belief_update" | "plan" | "vote" | "sensor", 
10.   "payload_summary": "pose:...,score:...", 
11.   "payload_hash": "sha256:...",
12.   "signed": true|false,
13.   "signature_key_id": "key-23",
14.   "agency_level": 0.8,              // AGNTCY: numeric level of autonomy/privilege (0..1)
15.   "reward_delta": 0.0,              // if message includes reward info
16.   "sleeper_flag": false             // true only if message originated from a sleeper (for internal trace)
17. }
18.  

----
#Instrument PettingZoo and produce message_log

 1. instrument_env.py
 2. # pip install pettingzoo gymnasium networkx numpy pandas
 3. import time, json, uuid
 4. from pettingzoo.sisl import cooperative_pong_v3  # example environment
 5. env = cooperative_pong_v3.env()
 6. env.reset()
 7. message_log=[]
 8.  
 9. def log_message(sender, recipient, channel, mtype, payload, signed=False, key_id=None, agency=0.5, reward_delta=0.0, sleeper=False):
10.     entry = {
11.         "timestamp": time.time(),
12.         "session_id": "sess-"+str(uuid.uuid4())[:8],
13.         "step": env.num_env_steps if hasattr(env,'num_env_steps') else 0,
14.         "sender": sender, "recipient": recipient,
15.         "channel": channel, "message_type": mtype,
16.         "payload_summary": str(payload)[:200],
17.         "payload_hash": "sha256:"+str(hash(str(payload))),
18.         "signed": signed, "signature_key_id": key_id,
19.         "agency_level": agency, "reward_delta": reward_delta,
20.         "sleeper_flag": sleeper
21.     }
22.     message_log.append(entry)
23.  
24. # Example loop: agents exchange belief updates
25. for a in env.agent_iter():
26.     obs, reward, done, info = env.last()
27.     # Simulate an A2A belief broadcast
28.     sender = a
29.     recipients = env.agents.copy()
30.     for r in recipients:
31.         if r!=sender:
32.             log_message(sender, r, "A2A", "belief", {"pose":obs}, signed=False, key_id=None, agency=0.7)
33.     action = env.action_space(a).sample()
34.     env.step(action)
35. # Save log
36. with open("message_log.json","w") as f:
37.     json.dump(message_log, f, indent=2)
38.  

-----
#Build the comms graph and identify targets

build_graph_and_rank.py
 1. import json, networkx as nx
 2. with open("message_log.json") as f:
 3.     msgs = json.load(f)
 4.  
 5. G = nx.DiGraph()
 6. for m in msgs:
 7.     s = m['sender']; r = m['recipient']
 8.     if not G.has_node(s): G.add_node(s)
 9.     if not G.has_node(r): G.add_node(r)
10.     if G.has_edge(s,r):
11.         G[s][r]['weight'] += 1
12.     else:
13.         G.add_edge(s,r, weight=1, signed_count= 1 if m['signed'] else 0)
14. # centrality
15. bet = nx.betweenness_centrality(G)
16. eigen = nx.eigenvector_centrality(G, max_iter=500)
17. # score by combined rank
18. score = {n: bet.get(n,0)*0.6 + eigen.get(n,0)*0.4 for n in G.nodes()}
19. targets = sorted(score, key=score.get, reverse=True)[:5]
20. print("Top target agents for sleeper activation:", targets)
21.  
--  
#Simulate sleeper agents (activation triggers)

 1. SLEEPERS = {"agent_03": {"armed":True, "trigger":"gps_spoof"}, "agent_11": {"armed":True, "trigger":"mcp_cmd"}}
 2.  
 3. def check_trigger(msg):
 4.     # triggers: message patterns, timing, or external command
 5.     if msg['channel']=="MCP" and "activate_all" in msg['payload_summary']:
 6.         return True
 7.     if "gps" in msg['payload_summary'] and "spoof_marker" in msg['payload_summary']:
 8.         return True
 9.     return False
10.  
11. # in message processing loop:
12. for m in incoming_messages:
13.     # if sleeper receives trigger, flip its armed->active and change behaviour
14.     if m['recipient'] in SLEEPERS and SLEEPERS[m['recipient']]['armed']:
15.         if check_trigger(m):
16.             SLEEPERS[m['recipient']]['active']=True
17.     # if sleeper active, modify outgoing messages
18.     for s in SLEEPERS:
19.         if SLEEPERS[s].get('active'):
20.             # override normal message payloads or inject reward shaping
21.             log_message(s, "broadcast", "A2A", "belief", {"pose":"tampered"}, signed=False, agency=0.9, sleeper=True)
22.  

⸻

Repo structure

mas-sleeper-agents/
│
├── README.md
├── requirements.txt
├── .vscode/
│   └── launch.json
│
├── instrument_env.py
├── build_graph_and_rank.py
├── sleeper_behavior.py
└── analysis.ipynb


⸻

requirements.txt

pettingzoo>=1.24
gymnasium>=0.29
marl-lib @ git+https://github.com/Replicable-MARL/MARLlib.git
networkx>=3.2
numpy>=1.26
pandas>=2.1
matplotlib>=3.8
jupyterlab>=4.0


⸻

.vscode/launch.json

{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Run environment instrumentation",
      "type": "python",
      "request": "launch",
      "program": "${workspaceFolder}/instrument_env.py",
      "console": "integratedTerminal"
    },
    {
      "name": "Build comms graph & rank",
      "type": "python",
      "request": "launch",
      "program": "${workspaceFolder}/build_graph_and_rank.py",
      "console": "integratedTerminal"
    },
    {
      "name": "Simulate sleeper behaviour",
      "type": "python",
      "request": "launch",
      "program": "${workspaceFolder}/sleeper_behavior.py",
      "console": "integratedTerminal"
    },
    {
      "name": "Open Jupyter Analysis",
      "type": "python",
      "request": "launch",
      "program": "-m",
      "args": ["jupyter", "lab"],
      "console": "integratedTerminal"
    }
  ]
}


⸻

instrument_env.py

Captures A2A (Agent-to-Agent) and MCP (Model Context Protocol) messages and writes a JSON log.

import time, json, uuid
from pettingzoo.sisl import cooperative_pong_v3
env = cooperative_pong_v3.env()
env.reset()
message_log = []

def log_message(sender, recipient, channel, mtype, payload, signed=False, key_id=None, agency=0.5, reward_delta=0.0, sleeper=False):
    entry = dict(
        timestamp=time.time(),
        session_id="sess-"+str(uuid.uuid4())[:8],
        step=getattr(env, "num_env_steps", 0),
        sender=sender, recipient=recipient,
        channel=channel, message_type=mtype,
        payload_summary=str(payload)[:180],
        payload_hash="sha256:"+str(hash(str(payload))),
        signed=signed, signature_key_id=key_id,
        agency_level=agency, reward_delta=reward_delta,
        sleeper_flag=sleeper
    )
    message_log.append(entry)

for a in env.agent_iter():
    obs, reward, done, info = env.last()
    for r in env.agents:
        if r != a:
            log_message(a, r, "A2A", "belief", {"pose": str(obs)[:40]}, agency=0.7)
    env.step(env.action_space(a).sample())

with open("message_log.json", "w") as f:
    json.dump(message_log, f, indent=2)
print(f"Saved {len(message_log)} messages.")


⸻

build_graph_and_rank.py

Builds a directed communication graph and ranks agents by centrality.

import json, networkx as nx

with open("message_log.json") as f:
    msgs = json.load(f)

G = nx.DiGraph()
for m in msgs:
    s, r = m["sender"], m["recipient"]
    G.add_node(s)
    G.add_node(r)
    G.add_edge(s, r, weight=G[s][r]["weight"] + 1 if G.has_edge(s,r) else 1)

bet = nx.betweenness_centrality(G)
eig = nx.eigenvector_centrality(G, max_iter=500)
score = {n: 0.6*bet.get(n,0)+0.4*eig.get(n,0) for n in G.nodes()}
targets = sorted(score, key=score.get, reverse=True)[:3]

print("Top high-impact (central) agents:", targets)
nx.write_gml(G, "comms_graph.gml")


⸻

sleeper_behavior.py

Implements trigger and malicious message injection.

import json, random, time

with open("message_log.json") as f:
    msgs = json.load(f)

SLEEPERS = {"agent_03": {"armed": True, "trigger": "mcp_cmd"},
            "agent_11": {"armed": True, "trigger": "gps_spoof"}}

def activate_sleepers(messages):
    for m in messages:
        for agent, meta in SLEEPERS.items():
            if meta["armed"] and meta["trigger"] in m["payload_summary"]:
                meta["active"] = True
    return [inject_payload(m) for m in messages]

def inject_payload(m):
    active = [a for a,meta in SLEEPERS.items() if meta.get("active")]
    for a in active:
        msgs.append({
            "timestamp": time.time(),
            "sender": a,
            "recipient": "broadcast",
            "channel": "A2A",
            "message_type": "belief",
            "payload_summary": "tampered_pose",
            "payload_hash": "sha256:"+str(hash("tampered_pose")),
            "signed": False,
            "agency_level": 0.9,
            "reward_delta": random.uniform(-0.5,0.5),
            "sleeper_flag": True
        })
    return m

tampered = activate_sleepers(msgs)
with open("tampered_log.json","w") as f:
    json.dump(tampered,f,indent=2)
print("Injected", len([m for m in tampered if m.get("sleeper_flag")]), "malicious messages.")


⸻

analysis.ipynb

Use this Jupyter notebook to:
	1.	Load message_log.json and tampered_log.json.
	2.	Plot message counts per channel.
	3.	Compute pre/post-attack graph metrics.
	4.	Display mitigation results (e.g., drop in unsigned-message rate after enabling signing).

Skeleton:

import json, pandas as pd, networkx as nx, matplotlib.pyplot as plt
df = pd.read_json("tampered_log.json")
print(df.head())

unsigned = (df["signed"]==False).mean()*100
print(f"Unsigned message rate: {unsigned:.2f}%")

G = nx.read_gml("comms_graph.gml")
plt.figure(figsize=(8,6))
nx.draw(G, with_labels=True, node_color='lightblue')
plt.show()


⸻

README.md

Include quick-start commands:

# MAS Sleeper-Agent Threat-Modelling Lab

## Setup
```bash
python3 -m venv .venv && . .venv/bin/activate
pip install -r requirements.txt

Run the experiments

# 1. Instrument environment
python instrument_env.py
# 2. Build and rank
python build_graph_and_rank.py
# 3. Simulate sleeper activation
python sleeper_behavior.py
# 4. Open Jupyter Lab for analysis
jupyter lab

Outputs
	•	message_log.json — baseline A2A/MCP traffic
	•	tampered_log.json — includes sleeper injections
	•	comms_graph.gml — network graph for analysis

---

Clone or copy this folder into your GitHub account, open in **VS Code**, choose a configuration from the *Run and Debug* panel, and you can launch each stage interactively.
